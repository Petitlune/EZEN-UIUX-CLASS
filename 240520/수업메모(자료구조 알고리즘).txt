* 자료구조 :
데이터가 어떤 구조로 저장되고 어떻게 사용되는지 나타내는 과정 및 결과

*알고리즘 :
어떤 문제를 해결하기 위한 최고 및 최선의 효율적인 방법(론)

*시간복잡도 :
해결하는데 걸리는 소요시간

arr = [1, 3, 5, 7]
=> 미션, 주어진 배열에서 5를 찾으세요

1) 직접 찾을 때 arr[2]
2) 반복문 순회하면서 찾기
3) 가장 안좋은 방법: 1, 3, 7 ~ 5 를 찾는 방법(배열의 길이 수 만큼 시간 걸림)

   => 가장 시간이 많이 걸리는 상황을 전제하에 시간 복잡도 계산

(시간 복잡도의 단위)
- 빅오메가 : 가장 최선의 경우, 한 번에 찾았을 때를 의미
- 빅세타 : 평균의 경우, 배열 길이의 중간만큼 시간이 걸리는 것을 의
- 빅오 : 최악의 경우, 배열의 길이만큼 시간이 걸리는 것을 의미

- 프로그래밍 영역에서는 시간이 가장 오래걸릴 것이라고 판단되는 구간을 발췌해서 시간 복잡도를 계산!
* 이터러블 객체가 구현하는 실행시간을 보고 판단. 
> 자료구조 & 알고리즘 
> 반복문 / 반복문 사용안하고 효율적인 코드는? 연결리스트 개념

 * 데이터 편집요소 기능 많은 경우 => 반복문 X, 연결리스트
 * 데이터 불러오거나 읽는 기능이 주된 기능 => 배열 지향

* 연결리스트는 배열이 아니지만 배열과 유사한 기능 구현

*연결리스트를 활용해서 구현할 수 있는 기능 및 연산작업을 하나씩 > 추상자료형

1) 연결리스트이 모든 데이터를 출력하는 기능
>printAll( )
2) 연결리스트이 모든 데이터를 제거 기능
>clear()
3) 연결리스트 내 인덱스를 삽입 기능
>insertAt(index, data)
4) 연결리스트 내 인덱스를 삭제 기능
>deleteAt(index)
5) 연결리스트 내 인덱스를 읽는 기능
>getNodeAt(index)
6) 연결리스트 내 인덱스를  마지막에 삽입 기능
>insertLast(data)
7) 연결리스트 내 인덱스를 마지막에 삭제 기능
>deleteLast(data)


*연결리스트 => Stack & Call

1) stack : 아주 단순한 규칙을 가지고 있는 기능
 > 특징: 나중에 들어간 데이터가 반드시 먼저 나오는 규칙(LIFO)

- push( ) : 데이터를 삽입하는 함수
- pop( ) : 데이터를 제거하는 함수
- peek( ) : 데이터를 참조하는 함수
- isEmpty( ) : 데이터가 비어있는지 여부를 체크하는 함수

2) Queue(큐) => 대기하다 : 놀이동산과 e-mart 생각하면 됨. 
ex) 웹브라우저 > html, css, js

- enque( ) : 데이터를 삽입하는 함수
- deque( ) : 데이터를 제거하는 함수
- front( ) : 데이터를 참조하는 함수
-  isEmpty( ) : 데이터가 비어있는지 여부를 체크하는 함수

3) deque : 삽입과 제거를 head와 tail에서 두 군데에서 모두 할 수 있음.


- 해시테이블 = hash table
> stack / queue / dequeue

- 테이블 형식( *행 & 열 구조)
- 행. 열 데이터 하나씩 넣는 구조

- 해시 테이블의 장점 : 빠른 데이터 읽기 & 삭제 & 삽입
- 해시 테이블의 단점 : 기능의 효율성을 추구하는데 독립적이지 못하다 / 아무리 잘 만들어놔도 해시함수가 엉성하면 기능의 효율성이 아주 안좋아짐. 
무한하고 불규칙적 나열 데이터를 한정된 영역안에서 규칙적이고 효율적으로 관리하기 위한 목적으로 탄생된 테이블 형태의  자료 구조 => *해시 함수 : 해시테이블 구성하기 위해서 생성된 연산 함수

-자주 사용하는 기능 
 데이터 삽입 : add(data)
 데이터 체크 : isContain(data)
 데이터 제거 : remove(data)
 테이블 행 자료 비우기 : clear( )
 테이블에 데이터가 비어있는지 체크 : isEmpty( )
 테이블에 있는 모든 데이터를 출력 : printAll( )

- 셋 = set
JS iterable object : 반복 순회할 수 있다. 
 >for of / forEach / for in
> Map  규칙 / 이터러블한 객체로 만들어 줄 수 있었음(* next( ))
> Set => 이터러블한 객체로 만들어 줄 수 있었음 (하지만 중복되는 값은 허용하지 않는 규칙)

